#include <Windows.h>
#include <string>
#include <vector>
#include <sstream>
#include <fstream>
#include <regex>
#include <map>
#include <commctrl.h>
#include <Uxtheme.h>
#include <dwmapi.h>
#include <cctype>
#include <algorithm>

#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "Uxtheme.lib")
#pragma comment(lib, "dwmapi.lib")
#pragma comment(linker,"\"/manifestdependency:type='win32' \
name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

// Global variables for UI controls
HWND g_hTextBox, g_hButtonCompile, g_hButtonRun, g_hStatusBar;
HWND g_hTabControl, g_hExamplesList, g_hHelpBox;
HFONT g_hFontTitle, g_hFontNormal, g_hFontCode;
HBRUSH g_hBrushBackground;

// Color scheme
const COLORREF BATLANG_COLOR_BG = RGB(30, 30, 36);
const COLORREF BATLANG_COLOR_TEXTBOX_BG = RGB(37, 37, 44);
const COLORREF BATLANG_COLOR_TEXT = RGB(220, 220, 220);
const COLORREF BATLANG_COLOR_BUTTON = RGB(86, 86, 96);
const COLORREF BATLANG_COLOR_BUTTON_HOVER = RGB(106, 106, 116);
const COLORREF BATLANG_COLOR_ACCENT = RGB(118, 150, 255);
const COLORREF BATLANG_COLOR_ERROR = RGB(255, 80, 80);
const COLORREF BATLANG_COLOR_SUCCESS = RGB(80, 255, 80);

// Service flags
bool g_bGuiServiceEnabled = false;
bool g_bWindowsAPIServiceEnabled = false;

// Error structure
struct CompileError {
    int line;
    std::string message;
};

// Structure for code examples
struct CodeExample {
    std::wstring name;
    std::wstring code;
};

std::vector<CodeExample> examples = {
    {
        L"Language Basics",
        L"add name = \"BatLang\"\n"
        L"add version = 1.0\n"
        L"print(\"Hello World!\")\n"
        L"println(\"Double output\")\n"
        L"wait(2)\n"
        L"stop\n"
        L"end)"
    },
    {
        L"With Windows API",
        L"ServiceAdd <WindowsAPI.h>\n\n"
        L"title(\"System Info\")\n"
        L"color(2)\n"
        L"namepc()\n"
        L"ipcfg()\n"
        L"showdata()\n"
        L"time()\n"
        L"wait(3)\n"
        L"end)"
    },
    {
        L"Simple GUI Example",
        L"ServiceAdd <ServiceGui.h>\n\n"
        L"GuiService:AddGui(Frame)\n"
        L"GuiService.Name = \"My Window\"\n"
        L"GuiService:AddGui(Button)\n"
        L"Button.Text = \"Click Me!\"\n"
        L"$form.Controls.Add($button)\n"
        L"$form.ShowDialog()\n"
        L"end)"
    },
    {
        L"GUI with Multiple Buttons",
        L"ServiceAdd <ServiceGui.h>\n\n"
        L"GuiService:AddGui(Frame)\n"
        L"GuiService.Name = \"Test Window\"\n\n"
        L"GuiService:AddGui(Button)\n"
        L"Button.Text = \"Button 1\"\n"
        L"$button1 = $button\n\n"
        L"GuiService:AddGui(Button)\n"
        L"Button.Text = \"Button 2\"\n"
        L"$button2 = $button\n\n"
        L"$form.Controls.Add($button1)\n"
        L"$form.Controls.Add($button2)\n"
        L"$form.ShowDialog()\n"
        L"end)"
    }
};

// Helper function to trim whitespace
std::string TrimString(const std::string& str) {
    size_t first = str.find_first_not_of(" \t\r\n");
    if (first == std::string::npos) return "";
    size_t last = str.find_last_not_of(" \t\r\n");
    return str.substr(first, (last - first + 1));
}

// Helper function to convert string to lowercase
std::string ToLowerString(const std::string& str) {
    std::string result = str;
    std::transform(result.begin(), result.end(), result.begin(),
        [](unsigned char c) { return std::tolower(c); });
    return result;
}

// Function to extract quoted content
std::string ExtractQuotedContent(const std::string& str, size_t startPos) {
    size_t firstQuote = str.find('"', startPos);
    if (firstQuote == std::string::npos) return "";

    size_t secondQuote = str.find('"', firstQuote + 1);
    if (secondQuote == std::string::npos) return "";

    return str.substr(firstQuote + 1, secondQuote - firstQuote - 1);
}

// Function to check if line contains GUI commands
bool ContainsGuiCommands(const std::string& line) {
    std::string lowerLine = ToLowerString(line);
    return (lowerLine.find("guiservice:") != std::string::npos ||
        lowerLine.find("button.text") != std::string::npos ||
        lowerLine.find("$form.") != std::string::npos);
}

// Function to check if line contains Windows API commands
bool ContainsWindowsAPICommands(const std::string& line) {
    std::string lowerLine = ToLowerString(line);
    return (lowerLine.find("restart") != std::string::npos ||
        lowerLine.find("namepc()") != std::string::npos ||
        lowerLine.find("ipcfg()") != std::string::npos ||
        lowerLine.find("ping(") != std::string::npos ||
        lowerLine.find("programlist()") != std::string::npos ||
        lowerLine.find("kill(") != std::string::npos ||
        lowerLine.find("showdata()") != std::string::npos ||
        lowerLine.find("time()") != std::string::npos ||
        lowerLine.find("msgbox(") != std::string::npos ||
        lowerLine.find("openurl(") != std::string::npos ||
        lowerLine.find("beep(") != std::string::npos);
}

// Function to validate services
std::vector<CompileError> ValidateServices(const std::string& sourceCode) {
    std::vector<CompileError> errors;
    std::istringstream stream(sourceCode);
    std::string line;
    int lineNumber = 0;

    g_bGuiServiceEnabled = false;
    g_bWindowsAPIServiceEnabled = false;

    // First pass - check for service declarations (case insensitive, trim spaces)
    while (std::getline(stream, line)) {
        lineNumber++;

        std::string trimmedLine = TrimString(line);
        std::string lowerLine = ToLowerString(trimmedLine);

        // Check for GUI service (support both formats)
        if (lowerLine.find("serviceadd <guiservice.h>") != std::string::npos ||
            lowerLine.find("serviceadd <servicegui.h>") != std::string::npos) {
            g_bGuiServiceEnabled = true;
        }

        // Check for Windows API service
        if (lowerLine.find("serviceadd <windowsapi.h>") != std::string::npos) {
            g_bWindowsAPIServiceEnabled = true;
        }
    }

    // Reset stream for second pass
    stream.clear();
    stream.seekg(0);
    lineNumber = 0;

    // Second pass - validate usage
    while (std::getline(stream, line)) {
        lineNumber++;

        std::string trimmedLine = TrimString(line);

        // Skip service declaration lines
        if (trimmedLine.find("ServiceAdd <") != std::string::npos) {
            continue;
        }

        if (ContainsGuiCommands(trimmedLine) && !g_bGuiServiceEnabled) {
            CompileError error;
            error.line = lineNumber;
            error.message = "You Forgot To Add Service \"ServiceGui.h\"";
            errors.push_back(error);
        }

        if (ContainsWindowsAPICommands(trimmedLine) && !g_bWindowsAPIServiceEnabled) {
            CompileError error;
            error.line = lineNumber;
            error.message = "You Forgot To Add Service \"WindowsAPI.h\"";
            errors.push_back(error);
        }
    }

    return errors;
}

// Function to compile GUI section - С ПОДДЕРЖКОЙ TEXTBOX
std::string CompileGuiSection(std::istringstream& stream, std::string& currentLine, int& lineNumber) {
    std::stringstream result;
    std::stringstream psScript;

    // Process the first line (GuiService:AddGui(Frame))
    std::string trimmedCurrent = TrimString(currentLine);
    if (trimmedCurrent.find("GuiService:AddGui(Frame)") != std::string::npos) {
        psScript << "Add-Type -AssemblyName System.Windows.Forms; ";
        psScript << "Add-Type -AssemblyName System.Drawing; ";
        psScript << "$form = New-Object System.Windows.Forms.Form; ";
        psScript << "$form.Size = New-Object System.Drawing.Size(400,300); ";
        psScript << "$form.StartPosition = 'CenterScreen'; ";
    }

    std::string line;
    bool inGuiSection = true;
    int buttonCounter = 0;
    int textboxCounter = 0;
    int yPos = 20;
    std::vector<std::string> controlVars; // Store all control variable names

    while (inGuiSection && std::getline(stream, line)) {
        lineNumber++;
        std::string trimmedLine = TrimString(line);

        if (trimmedLine.find("end)") != std::string::npos) {
            // Add all controls to the form
            for (const auto& ctrl : controlVars) {
                psScript << "$form.Controls.Add($" << ctrl << "); ";
            }
            psScript << "$form.ShowDialog(); ";
            result << "powershell -NoProfile -ExecutionPolicy Bypass -Command \"" << psScript.str() << "\"\n";
            result << "pause\n";
            return result.str();
        }

        if (trimmedLine.empty()) {
            continue;
        }

        // GuiService.Name = "title"
        if (trimmedLine.find("GuiService.Name =") != std::string::npos) {
            std::regex nameRegex("GuiService\\.Name\\s*=\\s*\"(.*?)\"");
            std::smatch match;
            if (std::regex_search(trimmedLine, match, nameRegex)) {
                psScript << "$form.Text = '" << match[1] << "'; ";
            }
        }

        // GuiService:AddGui(Button)
        else if (trimmedLine.find("GuiService:AddGui(Button)") != std::string::npos) {
            buttonCounter++;
            std::string btnVar = "button" + std::to_string(buttonCounter);
            controlVars.push_back(btnVar);

            psScript << "$" << btnVar << " = New-Object System.Windows.Forms.Button; ";
            psScript << "$" << btnVar << ".Location = New-Object System.Drawing.Point(20," << yPos << "); ";
            psScript << "$" << btnVar << ".Size = New-Object System.Drawing.Size(100,30); ";
            yPos += 40;
        }

        // GuiService:AddGui(Textbox)
        else if (trimmedLine.find("GuiService:AddGui(Textbox)") != std::string::npos ||
            trimmedLine.find("GuiService:AddGui(TextBox)") != std::string::npos) {
            textboxCounter++;
            std::string txtVar = "textbox" + std::to_string(textboxCounter);
            controlVars.push_back(txtVar);

            psScript << "$" << txtVar << " = New-Object System.Windows.Forms.TextBox; ";
            psScript << "$" << txtVar << ".Location = New-Object System.Drawing.Point(20," << yPos << "); ";
            psScript << "$" << txtVar << ".Size = New-Object System.Drawing.Size(200,30); ";
            yPos += 40;
        }

        // Button.Text = "text"
        else if (trimmedLine.find("Button.Text =") != std::string::npos) {
            std::regex textRegex("Button\\.Text\\s*=\\s*\"(.*?)\"");
            std::smatch match;
            if (std::regex_search(trimmedLine, match, textRegex)) {
                psScript << "$button" << buttonCounter << ".Text = '" << match[1] << "'; ";
            }
        }

        // Textbox.Text = "text"
        else if (trimmedLine.find("Textbox.Text =") != std::string::npos ||
            trimmedLine.find("TextBox.Text =") != std::string::npos) {
            std::regex textRegex("(?:Textbox|TextBox)\\.Text\\s*=\\s*\"(.*?)\"");
            std::smatch match;
            if (std::regex_search(trimmedLine, match, textRegex)) {
                psScript << "$textbox" << textboxCounter << ".Text = '" << match[1] << "'; ";
            }
        }

        // Textbox.Width = value
        else if (trimmedLine.find("Textbox.Width =") != std::string::npos ||
            trimmedLine.find("TextBox.Width =") != std::string::npos) {
            std::regex widthRegex("(?:Textbox|TextBox)\\.Width\\s*=\\s*(\\d+)");
            std::smatch match;
            if (std::regex_search(trimmedLine, match, widthRegex)) {
                psScript << "$textbox" << textboxCounter << ".Width = " << match[1] << "; ";
            }
        }

        // Textbox.Height = value
        else if (trimmedLine.find("Textbox.Height =") != std::string::npos ||
            trimmedLine.find("TextBox.Height =") != std::string::npos) {
            std::regex heightRegex("(?:Textbox|TextBox)\\.Height\\s*=\\s*(\\d+)");
            std::smatch match;
            if (std::regex_search(trimmedLine, match, heightRegex)) {
                psScript << "$textbox" << textboxCounter << ".Height = " << match[1] << "; ";
            }
        }

        // Textbox.Top = value
        else if (trimmedLine.find("Textbox.Top =") != std::string::npos ||
            trimmedLine.find("TextBox.Top =") != std::string::npos) {
            std::regex topRegex("(?:Textbox|TextBox)\\.Top\\s*=\\s*(\\d+)");
            std::smatch match;
            if (std::regex_search(trimmedLine, match, topRegex)) {
                psScript << "$textbox" << textboxCounter << ".Top = " << match[1] << "; ";
            }
        }

        // Textbox.Left = value
        else if (trimmedLine.find("Textbox.Left =") != std::string::npos ||
            trimmedLine.find("TextBox.Left =") != std::string::npos) {
            std::regex leftRegex("(?:Textbox|TextBox)\\.Left\\s*=\\s*(\\d+)");
            std::smatch match;
            if (std::regex_search(trimmedLine, match, leftRegex)) {
                psScript << "$textbox" << textboxCounter << ".Left = " << match[1] << "; ";
            }
        }

        // $form.Controls.Add($control)
        else if (trimmedLine.find("$form.Controls.Add") != std::string::npos) {
            // This line is now handled automatically at the end
            // But we'll still process it if the user writes it explicitly
            psScript << trimmedLine << "; ";
        }

        // Button events (click)
        else if (trimmedLine.find("$button.Add_Click") != std::string::npos) {
            psScript << trimmedLine << "; ";
        }
    }

    // Add all controls to the form
    for (const auto& ctrl : controlVars) {
        psScript << "$form.Controls.Add($" << ctrl << "); ";
    }
    psScript << "$form.ShowDialog(); ";
    result << "powershell -NoProfile -ExecutionPolicy Bypass -Command \"" << psScript.str() << "\"\n";
    result << "pause\n";
    return result.str();
}
// Function to compile BatLang to BAT
std::string CompileBatLang(const std::string& sourceCode, std::vector<CompileError>& errors) {
    std::stringstream result;
    std::istringstream stream(sourceCode);
    std::string line;
    std::map<std::string, std::string> variables;
    bool compiling = true;
    int indentLevel = 0;
    int lineNumber = 0;

    // Validate services first
    errors = ValidateServices(sourceCode);
    if (!errors.empty()) {
        return "";
    }

    result << "@echo off\n";
    result << "setlocal enabledelayedexpansion\n\n";

    while (std::getline(stream, line)) {
        lineNumber++;

        std::string trimmedLine = TrimString(line);

        if (trimmedLine.empty()) continue;

        // Skip service declarations
        if (trimmedLine.find("ServiceAdd <") != std::string::npos) {
            continue;
        }

        // Check for end of compilation
        if (trimmedLine.find("end)") != std::string::npos) {
            compiling = false;
            break;
        }

        if (!compiling) continue;

        // Handle GUI section
        if (trimmedLine.find("GuiService:AddGui(Frame)") != std::string::npos && g_bGuiServiceEnabled) {
            std::string guiCode = CompileGuiSection(stream, line, lineNumber);
            result << guiCode;
            continue;
        }

        // add command
        if (trimmedLine.substr(0, 3) == "add") {
            std::regex addRegex("add\\s+(\\w+)\\s*=\\s*(.*)");
            std::smatch match;

            if (std::regex_match(trimmedLine, match, addRegex)) {
                std::string varName = match[1];
                std::string varValue = match[2];

                if (varValue.find('"') == 0) {
                    std::string strValue = ExtractQuotedContent(trimmedLine, trimmedLine.find('=') + 1);
                    result << "set " << varName << "=" << strValue << "\n";
                    variables[varName] = strValue;
                }
                else if (varValue.find('+') != std::string::npos ||
                    varValue.find('-') != std::string::npos ||
                    varValue.find('*') != std::string::npos ||
                    varValue.find('/') != std::string::npos) {
                    result << "set /a " << varName << "=" << varValue << "\n";
                }
                else {
                    result << "set /a " << varName << "=" << varValue << "\n";
                }
            }
        }

        // print command
        else if (trimmedLine.substr(0, 5) == "print") {
            size_t openParen = trimmedLine.find('(');
            size_t closeParen = trimmedLine.find(')');

            if (openParen != std::string::npos && closeParen != std::string::npos) {
                std::string content = trimmedLine.substr(openParen + 1, closeParen - openParen - 1);
                content = TrimString(content);

                if (content.find('"') == 0) {
                    std::string text = ExtractQuotedContent(trimmedLine, openParen + 1);
                    result << "echo " << text << "\n";
                }
                else if (content.find('+') != std::string::npos ||
                    content.find('-') != std::string::npos ||
                    content.find('*') != std::string::npos ||
                    content.find('/') != std::string::npos) {
                    result << "set /a result=" << content << "\n";
                    result << "echo !result!\n";
                }
                else {
                    result << "echo %" << content << "%\n";
                }
            }
        }

        // println command
        else if (trimmedLine.substr(0, 7) == "println") {
            size_t openParen = trimmedLine.find('(');
            size_t closeParen = trimmedLine.find(')');

            if (openParen != std::string::npos && closeParen != std::string::npos) {
                std::string content = trimmedLine.substr(openParen + 1, closeParen - openParen - 1);
                content = TrimString(content);

                if (content.find('"') == 0) {
                    std::string text = ExtractQuotedContent(trimmedLine, openParen + 1);
                    result << "echo " << text << "\n";
                    result << "echo " << text << "\n";
                }
                else {
                    result << "echo %" << content << "%\n";
                    result << "echo %" << content << "%\n";
                }
            }
        }

        // wait command
        else if (trimmedLine.substr(0, 4) == "wait") {
            std::regex waitRegex("wait\\(\\s*(\\d+)\\s*\\)");
            std::smatch match;

            if (std::regex_match(trimmedLine, match, waitRegex)) {
                result << "timeout /t " << match[1] << " /nobreak >nul\n";
            }
        }

        // sleep command
        else if (trimmedLine.substr(0, 5) == "sleep") {
            std::regex sleepRegex("sleep\\(\\s*(\\d+)\\s*\\)");
            std::smatch match;

            if (std::regex_match(trimmedLine, match, sleepRegex)) {
                result << "timeout /t " << match[1] << " /nobreak >nul\n";
            }
        }

        // if command
        else if (trimmedLine.substr(0, 2) == "if") {
            std::regex ifRegex("if\\s+not\\s+(\\w+)\\s*=\\s*(\\w+)");
            std::smatch match;

            if (std::regex_match(trimmedLine, match, ifRegex)) {
                result << "if not %" << match[1] << "%==%" << match[2] << "% (\n";
                indentLevel++;
            }
        }

        // end command
        else if (trimmedLine == "end") {
            if (indentLevel > 0) {
                result << ")\n";
                indentLevel--;
            }
        }

        // stop command
        else if (trimmedLine == "stop") {
            result << "pause\n";
        }

        // clear command
        else if (trimmedLine == "clear") {
            result << "cls\n";
        }

        // color command
        else if (trimmedLine.substr(0, 5) == "color") {
            std::regex colorRegex("color\\(\\s*(\\d+)\\s*\\)");
            std::smatch match;

            if (std::regex_match(trimmedLine, match, colorRegex)) {
                result << "color " << match[1] << "\n";
            }
        }

        // title command
        else if (trimmedLine.substr(0, 5) == "title") {
            size_t openParen = trimmedLine.find('(');
            size_t closeParen = trimmedLine.find(')');

            if (openParen != std::string::npos && closeParen != std::string::npos) {
                std::string content = trimmedLine.substr(openParen + 1, closeParen - openParen - 1);
                content = TrimString(content);

                if (content.find('"') == 0) {
                    std::string title = ExtractQuotedContent(trimmedLine, openParen + 1);
                    result << "title " << title << "\n";
                }
                else {
                    result << "title " << content << "\n";
                }
            }
        }

        // Windows API commands
        else if (g_bWindowsAPIServiceEnabled) {
            if (trimmedLine == "restart") {
                result << "shutdown /r /t 0\n";
            }
            else if (trimmedLine == "Close()") {
                result << "exit\n";
            }
            else if (trimmedLine == "namepc()") {
                result << "hostname\n";
            }
            else if (trimmedLine == "ipcfg()") {
                result << "ipconfig\n";
            }
            else if (trimmedLine.substr(0, 4) == "ping") {
                size_t openParen = trimmedLine.find('(');
                size_t closeParen = trimmedLine.find(')');

                if (openParen != std::string::npos && closeParen != std::string::npos) {
                    std::string target = trimmedLine.substr(openParen + 1, closeParen - openParen - 1);
                    target = TrimString(target);

                    if (target.find('"') == 0) {
                        target = ExtractQuotedContent(trimmedLine, openParen + 1);
                    }
                    result << "ping " << target << "\n";
                }
            }
            else if (trimmedLine == "programlist()") {
                result << "tasklist\n";
            }
            else if (trimmedLine.substr(0, 4) == "kill") {
                size_t openParen = trimmedLine.find('(');
                size_t closeParen = trimmedLine.find(')');

                if (openParen != std::string::npos && closeParen != std::string::npos) {
                    std::string process = trimmedLine.substr(openParen + 1, closeParen - openParen - 1);
                    process = TrimString(process);

                    if (process.find('"') == 0) {
                        process = ExtractQuotedContent(trimmedLine, openParen + 1);
                    }
                    result << "taskkill /IM " << process << " /F\n";
                }
            }
            else if (trimmedLine == "showdata()") {
                result << "date /t\n";
            }
            else if (trimmedLine == "time()") {
                result << "time /t\n";
            }
            else if (trimmedLine.substr(0, 6) == "msgbox") {
                size_t openParen = trimmedLine.find('(');
                size_t closeParen = trimmedLine.find(')');

                if (openParen != std::string::npos && closeParen != std::string::npos) {
                    std::string text = trimmedLine.substr(openParen + 1, closeParen - openParen - 1);
                    text = TrimString(text);

                    if (text.find('"') == 0) {
                        text = ExtractQuotedContent(trimmedLine, openParen + 1);
                    }
                    result << "powershell -Command \"[System.Windows.Forms.MessageBox]::Show('" << text << "')\"\n";
                }
            }
            else if (trimmedLine.substr(0, 7) == "openurl") {
                size_t openParen = trimmedLine.find('(');
                size_t closeParen = trimmedLine.find(')');

                if (openParen != std::string::npos && closeParen != std::string::npos) {
                    std::string url = trimmedLine.substr(openParen + 1, closeParen - openParen - 1);
                    url = TrimString(url);

                    if (url.find('"') == 0) {
                        url = ExtractQuotedContent(trimmedLine, openParen + 1);
                    }
                    result << "start " << url << "\n";
                }
            }
            else if (trimmedLine.substr(0, 4) == "beep") {
                std::regex beepRegex("beep\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)");
                std::smatch match;

                if (std::regex_match(trimmedLine, match, beepRegex)) {
                    result << "powershell -c \"[console]::beep(" << match[1] << "," << match[2] << ")\"\n";
                }
            }
        }
    }

    result << "\npause\n";
    return result.str();
}

// Button subclass procedure
LRESULT CALLBACK ButtonSubclassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData) {
    switch (msg) {
    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);

        RECT rc;
        GetClientRect(hwnd, &rc);

        bool isHovered = GetWindowLongPtr(hwnd, GWLP_USERDATA) == 1;
        bool isPressed = GetAsyncKeyState(VK_LBUTTON) & 0x8000;

        COLORREF bgColor = isPressed ? BATLANG_COLOR_ACCENT : (isHovered ? BATLANG_COLOR_BUTTON_HOVER : BATLANG_COLOR_BUTTON);

        HBRUSH brush = CreateSolidBrush(bgColor);
        FillRect(hdc, &rc, brush);
        DeleteObject(brush);

        HPEN pen = CreatePen(PS_SOLID, 1, RGB(60, 60, 70));
        HPEN oldPen = (HPEN)SelectObject(hdc, pen);
        HBRUSH oldBrush = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));
        Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
        SelectObject(hdc, oldPen);
        SelectObject(hdc, oldBrush);
        DeleteObject(pen);

        wchar_t text[256];
        GetWindowTextW(hwnd, text, 256);

        SetBkMode(hdc, TRANSPARENT);
        SetTextColor(hdc, BATLANG_COLOR_TEXT);
        DrawTextW(hdc, text, -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

        EndPaint(hwnd, &ps);
        return 0;
    }

    case WM_MOUSEMOVE: {
        TRACKMOUSEEVENT tme = { sizeof(TRACKMOUSEEVENT), TME_LEAVE, hwnd, 0 };
        if (GetWindowLongPtr(hwnd, GWLP_USERDATA) != 1) {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, 1);
            TrackMouseEvent(&tme);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        break;
    }

    case WM_MOUSELEAVE: {
        SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
        InvalidateRect(hwnd, NULL, TRUE);
        break;
    }

    case WM_ERASEBKGND:
        return 1;
    }

    return DefSubclassProc(hwnd, msg, wParam, lParam);
}

// Function to compile and run BAT file
void CompileAndRun(bool runAfterCompile = false) {
    // Get text from TextBox
    int textLength = GetWindowTextLengthW(g_hTextBox);
    if (textLength == 0) {
        SetWindowTextW(g_hStatusBar, L"No code to compile!");
        MessageBoxW(NULL, L"Please enter some code to compile!", L"Warning", MB_OK | MB_ICONWARNING);
        return;
    }

    wchar_t* wBuffer = new wchar_t[textLength + 1];
    GetWindowTextW(g_hTextBox, wBuffer, textLength + 1);

    // Convert wchar_t to string
    int bufferSize = WideCharToMultiByte(CP_UTF8, 0, wBuffer, -1, NULL, 0, NULL, NULL);
    char* buffer = new char[bufferSize];
    WideCharToMultiByte(CP_UTF8, 0, wBuffer, -1, buffer, bufferSize, NULL, NULL);

    std::string sourceCode(buffer);
    delete[] wBuffer;
    delete[] buffer;

    // Update status
    SetWindowTextW(g_hStatusBar, L"Compiling...");

    // Compile code
    std::vector<CompileError> errors;
    std::string batCode = CompileBatLang(sourceCode, errors);

    // Show errors if any
    if (!errors.empty()) {
        std::stringstream errorMsg;
        errorMsg << "Compilation Errors:\n\n";
        for (const auto& error : errors) {
            errorMsg << "Line " << error.line << ": " << error.message << "\n";
        }

        std::wstring wErrorMsg = std::wstring(errorMsg.str().begin(), errorMsg.str().end());
        SetWindowTextW(g_hStatusBar, L"Compilation failed!");
        MessageBoxW(NULL, wErrorMsg.c_str(), L"Compilation Errors", MB_OK | MB_ICONERROR);
        return;
    }

    // Save to file
    std::ofstream batFile("program.bat");
    if (batFile.is_open()) {
        batFile << batCode;
        batFile.close();

        SetWindowTextW(g_hStatusBar, L"Compilation successful! program.bat created.");

        if (runAfterCompile) {
            ShellExecuteW(NULL, L"open", L"program.bat", NULL, NULL, SW_SHOW);
            SetWindowTextW(g_hStatusBar, L"Program started!");
        }
    }
    else {
        SetWindowTextW(g_hStatusBar, L"Error creating file!");
        MessageBoxW(NULL, L"Error creating file!\nMake sure you have write permissions.", L"Error", MB_OK | MB_ICONERROR);
    }
}

// Window procedure
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
    case WM_CREATE: {
        g_hBrushBackground = CreateSolidBrush(BATLANG_COLOR_BG);

        g_hFontTitle = CreateFontW(24, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
            DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
            DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, L"Segoe UI");

        g_hFontNormal = CreateFontW(14, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
            DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
            DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, L"Segoe UI");

        g_hFontCode = CreateFontW(16, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
            DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
            DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, L"Consolas");

        HWND hTitle = CreateWindowW(L"STATIC", L"BatLang IDE",
            WS_CHILD | WS_VISIBLE | SS_CENTER,
            10, 10, 780, 40, hwnd, NULL, NULL, NULL);
        SendMessageW(hTitle, WM_SETFONT, (WPARAM)g_hFontTitle, TRUE);

        INITCOMMONCONTROLSEX icex;
        icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icex.dwICC = ICC_TAB_CLASSES;
        InitCommonControlsEx(&icex);

        g_hTabControl = CreateWindowW(WC_TABCONTROL, NULL,
            WS_CHILD | WS_VISIBLE | TCS_FIXEDWIDTH,
            10, 60, 780, 30, hwnd, NULL, NULL, NULL);
        SendMessageW(g_hTabControl, WM_SETFONT, (WPARAM)g_hFontNormal, TRUE);

        TCITEMW tie;
        tie.mask = TCIF_TEXT;

        wchar_t tab1[] = L"Editor";
        wchar_t tab2[] = L"Examples";
        wchar_t tab3[] = L"Help";

        tie.pszText = tab1;
        TabCtrl_InsertItem(g_hTabControl, 0, &tie);
        tie.pszText = tab2;
        TabCtrl_InsertItem(g_hTabControl, 1, &tie);
        tie.pszText = tab3;
        TabCtrl_InsertItem(g_hTabControl, 2, &tie);

        g_hTextBox = CreateWindowExW(WS_EX_CLIENTEDGE, L"EDIT", L"",
            WS_CHILD | WS_VISIBLE | ES_MULTILINE |
            ES_AUTOVSCROLL | ES_AUTOHSCROLL | WS_VSCROLL | WS_HSCROLL,
            10, 95, 600, 300, hwnd, NULL, NULL, NULL);
        SendMessageW(g_hTextBox, WM_SETFONT, (WPARAM)g_hFontCode, TRUE);

        g_hExamplesList = CreateWindowW(WC_LISTVIEW, NULL,
            WS_CHILD | WS_BORDER | LVS_REPORT | LVS_SINGLESEL,
            10, 95, 600, 300, hwnd, NULL, NULL, NULL);
        SendMessageW(g_hExamplesList, WM_SETFONT, (WPARAM)g_hFontNormal, TRUE);

        LVCOLUMNW lvc;
        lvc.mask = LVCF_WIDTH | LVCF_TEXT;
        lvc.cx = 580;
        wchar_t colName[] = L"Code Examples";
        lvc.pszText = colName;
        ListView_InsertColumn(g_hExamplesList, 0, &lvc);

        for (size_t i = 0; i < examples.size(); i++) {
            LVITEMW lvi;
            lvi.mask = LVIF_TEXT;
            lvi.iItem = (int)i;
            lvi.iSubItem = 0;
            lvi.pszText = (LPWSTR)examples[i].name.c_str();
            ListView_InsertItem(g_hExamplesList, &lvi);
        }

        ShowWindow(g_hExamplesList, SW_HIDE);

        g_hHelpBox = CreateWindowExW(WS_EX_CLIENTEDGE, L"EDIT",
            L"BatLang - Programming Language\n"
            L"================================\n\n"
            L"SERVICES (must be at the top):\n"
            L"• ServiceAdd <ServiceGui.h>   - Enable GUI\n"
            L"• ServiceAdd <WindowsAPI.h>    - Enable System commands\n\n"
            L"GUI COMMANDS:\n"
            L"• GuiService:AddGui(Frame)     - Create window\n"
            L"• GuiService.Name = \"title\"     - Set window title\n"
            L"• GuiService:AddGui(Button)    - Create button\n"
            L"• Button.Text = \"text\"          - Set button text\n"
            L"• $form.Controls.Add($button)   - Add button to form\n"
            L"• $form.ShowDialog()            - Show window\n\n"
            L"BASIC COMMANDS:\n"
            L"• add var = value               - Create variable\n"
            L"• print(\"text\")                  - Output text\n"
            L"• println(\"text\")                 - Double output\n"
            L"• wait(seconds)                  - Wait\n"
            L"• sleep(seconds)                  - Wait\n"
            L"• if not x = y                    - Condition\n"
            L"• end                             - End condition\n"
            L"• stop                            - Pause\n"
            L"• clear                           - Clear screen\n"
            L"• color(N)                         - Change color\n"
            L"• title(\"text\")                    - Set title\n\n"
            L"WINDOWS API COMMANDS:\n"
            L"• restart                          - Reboot\n"
            L"• Close()                          - Exit\n"
            L"• namepc()                          - Computer name\n"
            L"• ipcfg()                           - IP config\n"
            L"• ping(\"address\")                   - Ping\n"
            L"• programlist()                      - Process list\n"
            L"• kill(\"process.exe\")                - Kill process\n"
            L"• showdata()                         - Date\n"
            L"• time()                             - Time\n"
            L"• msgbox(\"text\")                     - Message box\n"
            L"• openurl(\"link\")                    - Open URL\n"
            L"• beep(freq, duration)               - Beep sound\n"
            L"• end)                               - End program",
            WS_CHILD | WS_VISIBLE | ES_MULTILINE | ES_READONLY | WS_VSCROLL,
            10, 95, 600, 300, hwnd, NULL, NULL, NULL);
        SendMessageW(g_hHelpBox, WM_SETFONT, (WPARAM)g_hFontNormal, TRUE);

        g_hButtonCompile = CreateWindowW(L"BUTTON", L"Compile",
            WS_CHILD | WS_VISIBLE | BS_OWNERDRAW,
            620, 95, 170, 45, hwnd, (HMENU)1, NULL, NULL);
        SendMessageW(g_hButtonCompile, WM_SETFONT, (WPARAM)g_hFontNormal, TRUE);
        SetWindowSubclass(g_hButtonCompile, ButtonSubclassProc, 0, 0);

        g_hButtonRun = CreateWindowW(L"BUTTON", L"▶️ Run",
            WS_CHILD | WS_VISIBLE | BS_OWNERDRAW,
            620, 150, 170, 45, hwnd, (HMENU)2, NULL, NULL);
        SendMessageW(g_hButtonRun, WM_SETFONT, (WPARAM)g_hFontNormal, TRUE);
        SetWindowSubclass(g_hButtonRun, ButtonSubclassProc, 0, 0);

        const wchar_t* quickCommands[] = { L"add", L"print", L"wait", L"stop", L"clear", L"end)" };
        for (int i = 0; i < 6; i++) {
            HWND hQuickBtn = CreateWindowW(L"BUTTON", quickCommands[i],
                WS_CHILD | WS_VISIBLE | BS_OWNERDRAW,
                620 + (i % 2) * 85, 205 + (i / 2) * 40, 80, 35,
                hwnd, (HMENU)(10 + i), NULL, NULL);
            SendMessageW(hQuickBtn, WM_SETFONT, (WPARAM)g_hFontNormal, TRUE);
            SetWindowSubclass(hQuickBtn, ButtonSubclassProc, 0, 0);
        }

        HWND hServiceGuiBtn = CreateWindowW(L"BUTTON", L"Add GUI",
            WS_CHILD | WS_VISIBLE | BS_OWNERDRAW,
            620, 305, 80, 35, hwnd, (HMENU)20, NULL, NULL);
        SendMessageW(hServiceGuiBtn, WM_SETFONT, (WPARAM)g_hFontNormal, TRUE);
        SetWindowSubclass(hServiceGuiBtn, ButtonSubclassProc, 0, 0);

        HWND hServiceApiBtn = CreateWindowW(L"BUTTON", L"Add WinAPI",
            WS_CHILD | WS_VISIBLE | BS_OWNERDRAW,
            710, 305, 80, 35, hwnd, (HMENU)21, NULL, NULL);
        SendMessageW(hServiceApiBtn, WM_SETFONT, (WPARAM)g_hFontNormal, TRUE);
        SetWindowSubclass(hServiceApiBtn, ButtonSubclassProc, 0, 0);

        g_hStatusBar = CreateWindowW(L"STATIC", L"Ready",
            WS_CHILD | WS_VISIBLE | SS_CENTER,
            10, 400, 780, 30, hwnd, NULL, NULL, NULL);
        SendMessageW(g_hStatusBar, WM_SETFONT, (WPARAM)g_hFontNormal, TRUE);

        const wchar_t* exampleCode = examples[2].code.c_str(); // GUI example
        SetWindowTextW(g_hTextBox, exampleCode);

        SetWindowTheme(hwnd, L"Explorer", NULL);
        break;
    }

    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORLISTBOX: {
        HDC hdc = (HDC)wParam;
        SetBkMode(hdc, TRANSPARENT);
        SetTextColor(hdc, BATLANG_COLOR_TEXT);
        SetBkColor(hdc, BATLANG_COLOR_TEXTBOX_BG);
        return (LRESULT)CreateSolidBrush(BATLANG_COLOR_TEXTBOX_BG);
    }

    case WM_NOTIFY: {
        if (((LPNMHDR)lParam)->hwndFrom == g_hTabControl) {
            switch (((LPNMHDR)lParam)->code) {
            case TCN_SELCHANGE: {
                int sel = TabCtrl_GetCurSel(g_hTabControl);
                ShowWindow(g_hTextBox, sel == 0 ? SW_SHOW : SW_HIDE);
                ShowWindow(g_hExamplesList, sel == 1 ? SW_SHOW : SW_HIDE);
                ShowWindow(g_hHelpBox, sel == 2 ? SW_SHOW : SW_HIDE);
                break;
            }
            }
        }
        break;
    }

    case WM_COMMAND: {
        int wmId = LOWORD(wParam);

        switch (wmId) {
        case 1:
            CompileAndRun(false);
            break;

        case 2:
            CompileAndRun(true);
            break;

        case 10: case 11: case 12: case 13: case 14: case 15: {
            const wchar_t* commands[] = { L"add  = ", L"print(\"\" )", L"wait(1)", L"stop", L"clear", L"end)" };
            int index = wmId - 10;
            SendMessageW(g_hTextBox, EM_REPLACESEL, TRUE, (LPARAM)commands[index]);
            break;
        }

        case 20:
            SendMessageW(g_hTextBox, EM_REPLACESEL, TRUE, (LPARAM)L"ServiceAdd <ServiceGui.h>\n");
            break;

        case 21:
            SendMessageW(g_hTextBox, EM_REPLACESEL, TRUE, (LPARAM)L"ServiceAdd <WindowsAPI.h>\n");
            break;
        }

        if ((HWND)lParam == g_hExamplesList && HIWORD(wParam) == LBN_DBLCLK) {
            int selIndex = ListView_GetNextItem(g_hExamplesList, -1, LVNI_SELECTED);
            if (selIndex >= 0 && selIndex < (int)examples.size()) {
                SetWindowTextW(g_hTextBox, examples[selIndex].code.c_str());
                TabCtrl_SetCurSel(g_hTabControl, 0);
                ShowWindow(g_hTextBox, SW_SHOW);
                ShowWindow(g_hExamplesList, SW_HIDE);
                ShowWindow(g_hHelpBox, SW_HIDE);
            }
        }
        break;
    }

    case WM_SIZE: {
        int width = LOWORD(lParam);
        int height = HIWORD(lParam);

        SetWindowPos(g_hTextBox, NULL, 10, 95, width - 200, height - 150, SWP_NOZORDER);
        SetWindowPos(g_hExamplesList, NULL, 10, 95, width - 200, height - 150, SWP_NOZORDER);
        SetWindowPos(g_hHelpBox, NULL, 10, 95, width - 200, height - 150, SWP_NOZORDER);
        SetWindowPos(g_hStatusBar, NULL, 10, height - 45, width - 20, 30, SWP_NOZORDER);

        SetWindowPos(g_hButtonCompile, NULL, width - 180, 95, 170, 45, SWP_NOZORDER);
        SetWindowPos(g_hButtonRun, NULL, width - 180, 150, 170, 45, SWP_NOZORDER);

        for (int i = 0; i < 6; i++) {
            HWND hQuickBtn = GetDlgItem(hwnd, 10 + i);
            if (hQuickBtn) {
                SetWindowPos(hQuickBtn, NULL, width - 180 + (i % 2) * 85,
                    205 + (i / 2) * 40, 80, 35, SWP_NOZORDER);
            }
        }

        HWND hServiceGuiBtn = GetDlgItem(hwnd, 20);
        HWND hServiceApiBtn = GetDlgItem(hwnd, 21);
        if (hServiceGuiBtn && hServiceApiBtn) {
            SetWindowPos(hServiceGuiBtn, NULL, width - 180, 305, 80, 35, SWP_NOZORDER);
            SetWindowPos(hServiceApiBtn, NULL, width - 90, 305, 80, 35, SWP_NOZORDER);
        }
        break;
    }

    case WM_ERASEBKGND: {
        HDC hdc = (HDC)wParam;
        RECT rc;
        GetClientRect(hwnd, &rc);
        FillRect(hdc, &rc, g_hBrushBackground);
        return 1;
    }

    case WM_DESTROY: {
        DeleteObject(g_hFontTitle);
        DeleteObject(g_hFontNormal);
        DeleteObject(g_hFontCode);
        DeleteObject(g_hBrushBackground);
        PostQuitMessage(0);
        break;
    }

    default:
        return DefWindowProcW(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

// Entry point
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    const wchar_t CLASS_NAME[] = L"BatLangIDE";

    WNDCLASSW wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;
    wc.hbrBackground = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);

    RegisterClassW(&wc);

    HWND hwnd = CreateWindowExW(
        0, CLASS_NAME, L"BatLang",
        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
        CW_USEDEFAULT, CW_USEDEFAULT, 900, 600,
        NULL, NULL, hInstance, NULL
    );

    if (hwnd == NULL) {
        MessageBoxW(NULL, L"Failed to create window!", L"Error", MB_OK | MB_ICONERROR);
        return 0;
    }

    BOOL enableDarkMode = TRUE;
    DwmSetWindowAttribute(hwnd, DWMWA_USE_IMMERSIVE_DARK_MODE, &enableDarkMode, sizeof(enableDarkMode));

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}
